---
title: "Clinical score"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r include = FALSE}
knitr::opts_chunk$set(fig.retina = 2,
                      fig.align  = "center")
```


## Synopsis

* **1 discretizing the continuous variables**: here it's the temperature and the heart
rate. To start with, let's binarize it (but latter on we could run a random forest
algorithm in order to the look for the relationship and define an optimal number of
classes to discretize this variable)

* **2 run an ElasticNet logistic regression**: for a given discretization choice made on
the continuous variables, run an ElasticNet logistic regression, tuning the penalty and
mixture hyper-parameters by 10-fold cross-validation of the training data set.


## Parameters

The path to the data folder:

```{r}
data_path <- paste0("/Users/MarcChoisy/Library/CloudStorage/",
                    "OneDrive-OxfordUniversityClinicalResearchUnit/",
                    "GitHub/choisy/typhoid/")
```


## Packages

The required packages:

```{r}
required_packages <- c("dplyr", "purrr", "stringr", "rsample", "glmnet", "glmnetUtils",
                       "parallel")
```

Making sure that the required packages are installed:

```{r}
to_inst <- required_packages[! required_packages %in% installed.packages()[,"Package"]]
if (length(to_inst)) install.packages(to_inst)
rm(required_packages, to_inst)
```

Loading some of these packages:

```{r message = FALSE}
library(dplyr)
library(purrr)
library(rsample)
library(glmnet)
library(glmnetUtils)
```


## Reading the clean data

The path to the data:

```{r}
nepal <- readRDS(paste0(data_path, "clean_data/nepal.rds"))
```


## Feature engineering

Nepal data set:

```{r}
nepal2 <- nepal |> 
  mutate(across(c(Cough, Diarrhoea, vomiting, Abdopain, Constipation, Headache,
                  Anorexia, Nausea, Typhoid_IgM), ~ .x > 0)) |> 
  na.exclude()
```

```{r}
nepal3 <- select(nepal2, BloodCSResult, Cough:Hepatomegaly)
```

```{r}
nepal3 |> 
  select(where(is.logical)) |> 
  map(table)
```


## General functions

```{r}
moving_average <- function(x, w = 20) {
  x |>
    seq_along() |> 
    map(~ tail(c(0, x), -.x)) |> 
    head(-w  + 1) |> 
    map(head, w) |> 
    map_dbl(mean)
}
```

```{r}
plot_smooth <- function(x, w, data = nepal3) {
  data[order(data[[x]]), ] |> 
    select({{ x }}, BloodCSResult) |> 
    map_dfc(moving_average, w) |> 
    plot(col = 4)
}
```

```{r}
specificity <- function(x) {
  x[1, 1] / sum(x[1, ])
}
```

```{r}
sensitivity <- function(x) {
  x[2, 2] / sum(x[2, ])
}
```

This function is not used yet, maybe in testing:

```{r}
accuracy <- function(x) {
  sum(diag(x)) / sum(x)
}
```

```{r}
j_index <- function(x) {
  specificity(x) + sensitivity(x) - 1
}
```

A function that converts a named vector of coefficient values into a named vector of
points corresponding to a clinical score:

```{r}
coef2scores <- function(x, n) {
  xmin <- min(x)
  xmax <- max(x)
  stepv <- min(diff(seq(xmin, xmax, le = n)))
  ubrks <- seq(xmin - stepv, xmax + stepv, le = n)
  cbrks <- ubrks - ubrks[which.min(abs(ubrks))]
  setNames(sort(c(-(1:sum(cbrks < 0)), 1:sum(cbrks > 0)))[as.integer(cut(x, cbrks))],
           stringr::str_remove(names(x), "TRUE")) |> 
    tidyr::replace_na(0)
}
```

A function that computes the points from a data frame `df` of binary valued variable
and a vector `cscore` of clinical scores. The names of the data frame and the the
vector should be the same, although not necessarily in the same order.

```{r}
make_points <- function(df, cscore) {
  colSums(t(as.matrix(df)) * cscore[names(df)])
}
```

```{r}
df2list_rowwise <- function(x) {
  map(1:nrow(x), ~ slice(x, .x))  
}
```

```{r}
make_thresholds <- function(x) {
  seq(min2(x) + 1, max2(x) - 1)
}
```

This function is not used at all:

```{r}
#extract2 <- function(i, x) x[i]
```

```{r}
bootstraps2 <- function(data, ...) {
  x <- bootstraps(data, ...)
  map(x$splits, ~ data[.$in_id, ])
}
```

```{r}
log2fac <- function(x) {
  factor(x, levels = c("FALSE", "TRUE"))
}
```

```{r}
tune_model <- function(formula, data) {
  model <- cva.glmnet(formula, data, family = binomial)  
  lambdas <- map(model$modlist, ~ as_tibble(.x[1:2]))
  alphas <- rep(model$alpha, map_int(lambdas, nrow))
  the_grid <- bind_rows(lambdas)
  the_grid$alpha <- alphas
  the_grid |>
    filter(cvm == min(cvm)) |> 
    select(lambda, alpha) |> 
    unlist()
}
```

```{r}
min2 <- function(x) {
  sum(map_int(x, min, 0))
}
```

```{r}
max2 <- function(x) {
  sum(map_int(x, max, 0))
}
```

```{r}
mclapply2 <- function(...) {
  parallel::mclapply(..., mc.cores = parallel::detectCores() - 1)
}
```

```{r}
bind_cols2 <- function(x, y) {
  bind_cols(y, x)
}
```

```{r}
plot2 <- function(...) plot(..., col = 4)
```


## Specific functions

This function is not used at all:

```{r}
#make_clinical_scores <- function(x, n, penalty, mixture = 0) {
#  model <- glmnet(model.matrix(BloodCSResult ~ ., x)[, -1], as.factor(x$BloodCSResult),
#                  binomial, alpha = mixture, lambda = penalty)
#  coef2scores(coef(model)[-1, ], n)
#}
```

Looking for the best threshold values:

```{r}
compute_j <- function(test, temp, pulse, score, threshold) {
  tibble(obsv = log2fac(test$BloodCSResult),
         pred = log2fac(make_points(
           recoding(test, temp, pulse)[, -1], score) > threshold)) |> 
    table() |>
    j_index()
}
```

This function is not used at all:

```{r}
#j_from_threshold <- function(test, temp, pulse, score, thresholds) {
#  map_dbl(thresholds, compute_j, test = test, temp = temp, pulse = pulse, score = score)
#}
```

```{r}
recoding <- function(x, temp, pulse) {
  mutate(x, across(OralTemperature, ~ .x > temp),
            across(Pulse, ~ .x > pulse))
}
```

```{r}
confusion_matrix <- function(test, temp, pulse, score, threshold) {
  tibble(obsv = log2fac(test$BloodCSResult),
         pred = log2fac(make_points(
           recoding(test, temp, pulse)[, -1], score) > threshold)) |> 
    table()
}
```

```{r}
matrix_from_threshold <- function(test, temp, pulse, score, thresholds) {
  map(thresholds, confusion_matrix, test = test, temp = temp, pulse = pulse, score = score)
}
```

```{r}
find_best_threshold <- function(data, temp, pulse, score, thresholds) {
  data |> 
    bootstraps2() |> 
    map(matrix_from_threshold, temp = temp, pulse = pulse, score = score,
        thresholds = thresholds) |> 
    map(map, j_index) |> 
    unlist() |> 
    matrix(length(thresholds)) |> 
    rowMeans() |> 
    setNames(thresholds)
}
```

```{r}
n_t_j <- function(rowX, n_vals, data) {
  j_values <- n_vals |>
    map(coef2scores, x = unlist(rowX[["coeffs"]])) |> 
    map(~ find_best_threshold(data, rowX$temp, rowX$pulse, .x, make_thresholds(.x))) |> 
    map(~ .x[which.max(.x)])
  which_n <- which.max(j_values)
  tibble(n = n_vals[which_n], t = as.integer(names(j_values[[which_n]])), j = max(unlist(j_values)))
}
```

```{r}
tuned_coefficients <- function(x, temp, pulse) {
  x_rec <- recoding(x, temp, pulse)
  frmla <- BloodCSResult ~ .
  hyper <- tune_model(frmla, x_rec)
  model <- glmnet(model.matrix(frmla, x_rec)[, -1], as.factor(x_rec$BloodCSResult),
                  binomial, alpha = hyper["alpha"], lambda = hyper["lambda"])
  out <- coef(model)[-1, ]
  setNames(out, stringr::str_remove(names(out), "TRUE"))
}
```


## Spliting the data

Let's create the train and test data sets:

```{r}
data_split <- initial_split(nepal3)
train_data <- training(data_split)
test_data <- testing(data_split)
```


## Exploration of the effect of the continuous variables

```{r}
plot_smooth("OralTemperature", 120, nepal3)
plot_smooth("Pulse", 100, nepal3)
plot_smooth("OralTemperature", 120, train_data)
plot_smooth("Pulse", 100, train_data)
```


## Model training

Takes 20':

```{r}
grid1 <- expand.grid(temp = seq(35, 42, .5), pulse = seq(60, 130, 10)) |> 
  as_tibble() |> 
  mutate(coeffs = map2(temp, pulse, tuned_coefficients, x = train_data))
```

A parallelized version (takes ca 7'):

```{r}
temp_pulse_grid <- expand.grid(temp = seq(35, 42, .5),
                               pulse = seq(60, 130, 10))

temp_pulse_grid <- temp_pulse_grid |> 
  as_tibble() |> 
  mutate(coeffs = mclapply2(1:nrow(temp_pulse_grid), 
                            function(x) tuned_coefficients(train_data,
                                                           temp_pulse_grid$temp[x],
                                                           temp_pulse_grid$pulse[x])))
```

Takes 54':

```{r}
out_serial <- grid1 |> 
  df2list_rowwise() |> 
  map_dfr(n_t_j, 3:15, train_data) |> 
  bind_cols2(grid1)
```

A parallelized version (takes 11'):

```{r}
out_parallel <- temp_pulse_grid |> 
  df2list_rowwise() |> 
  mclapply2(n_t_j, n_vals = 3:15, data = train_data) |> 
  bind_rows() |> 
  bind_cols2(temp_pulse_grid)
```

```{r}
filter(out_serial, j == max(j))
filter(out_parallel, j == max(j))
```

Let's compare the first best models:

```{r}
arrange(out_serial, desc(j))
arrange(out_parallel, desc(j))
```

```{r}
add_position <- function(x) {
  x |> 
    arrange(desc(j)) |> 
    mutate(order = row_number())
}

out_all <- bind_rows(mutate(add_position(out_serial), batch = "serial"),
                     mutate(add_position(out_parallel), batch = "parallel"))
```

```{r}
with(out_all, plot(order, j, col = c(serial = 4, parallel = 2)[batch]))
```

This shows that there is still a bit of variability.

## Model testing

```{r}
best_model_serial <- filter(out_serial, j == max(j))
best_model_parallel <- filter(out_parallel, j == max(j))
```

```{r}
extract_score <- function(x) {
  with(x, list(tempt = temp,
               pulse = pulse,
               score = coef2scores(first(coeffs), n),
               thres = x$t))
}
```

```{r}
model_serial <- extract_score(best_model_serial)
model_parallel <- extract_score(best_model_parallel)
```

```{r}
make_predictions <- function(data, model) {
  data |> 
    recoding(model$tempt, model$pulse) |> 
    select(-BloodCSResult) |> 
    make_points(model$score) |> 
    magrittr::is_greater_than(model$thres)
}
```

```{r}
make_predictions(test_data, model_serial)
make_predictions(test_data, model_parallel)
```

```{r}
confmat_test <- function(data, model) {
  data |> 
    mutate(predictions = make_predictions(data, model)) |> 
    select(BloodCSResult, predictions) |> 
    mutate_all(log2fac) |> 
    table()
}
```

```{r}
confmat_serial <- confmat_test(test_data, model_serial)
confmat_parallel <- confmat_test(test_data, model_parallel)
```

```{r}
accuracy(confmat_serial)
sensitivity(confmat_serial)
specificity(confmat_serial)
j_index(confmat_serial)
```

```{r}
accuracy(confmat_parallel)
sensitivity(confmat_parallel)
specificity(confmat_parallel)
j_index(confmat_parallel)
```

```{r}
sensitivity(confmat_serial)
specificity(confmat_serial)
```
